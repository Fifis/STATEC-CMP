% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sa.R
\name{diagnoseSeasonalityOne}
\alias{diagnoseSeasonalityOne}
\alias{diagnoseSeasonality}
\title{Diagnose seasonality, adjust the series, print and visualise the results}
\usage{
diagnoseSeasonalityOne(
  x,
  calendar = NULL,
  name = "(noname)",
  nbcast = 0,
  nfcast = 0,
  transform = c("auto", "yes", "no"),
  td = c("auto", "6", "1", "no"),
  leap.year = c("auto", "yes", "no"),
  easter = c("auto", "yes", "no"),
  forced.outliers = NULL,
  m7.threshold = 1,
  sa.rule = c("robustM7", "M7", "averageM7", "yes", "no"),
  transform.aicdiff = -2,
  tradingdays.aicdiff = 0,
  plot.file = NULL,
  skip.boxplot = FALSE,
  verbose = 2
)

diagnoseSeasonality(
  x,
  calendar = NULL,
  name = "Y",
  bfcast.tails = FALSE,
  est.begin = NULL,
  est.end = NULL,
  bcast.begin = NULL,
  fcast.end = NULL,
  transform = c("auto", "yes", "no"),
  td = c("auto", "6", "1", "no"),
  leap.year = c("auto", "yes", "no"),
  easter = c("auto", "yes", "no"),
  forced.outliers = NULL,
  m7.threshold = 1,
  sa.rule = c("robustM7", "M7", "averageM7", "yes", "no"),
  transform.aicdiff = -2,
  tradingdays.aicdiff = 0,
  plot.file = NULL,
  skip.boxplot = FALSE,
  verbose = 2,
  split.long = TRUE,
  max.length = 15,
  overlap.length = 1,
  custom.est.starts = NULL,
  custom.est.ends = NULL,
  custom.blend.starts = NULL,
  custom.blend.ends = NULL,
  parallel = FALSE,
  mc.cores = 4
)
}
\arguments{
\item{x}{A univariate or multivariate time series of class `ts` or `mts`.
`diagnoseSeasonalityOne` accepts only univariate time series.}

\item{calendar}{An object of class `mts` containing calendar regressors: Monday, ..., Saturday, LeapYear, WorkingDays.
If NULL, the default X13 working-day calendar is used. If forecasting is required, should be longer than the series.}

\item{name}{A string with the name of the series for printing.}

\item{nbcast}{A non-negative integer: how many periods to backcast before the first valid observation (only for `diagnoseSeasonalityOne`)}

\item{nfcast}{A non-negative integer: how many periods to forecast after the last valid observation (only for `diagnoseSeasonalityOne`)}

\item{transform}{Character or logical: automatic transformation, or forced logarithmic, or none.
TRUE translates to "log", FALSE translates to "none", NA or NULL to "auto".}

\item{td}{Character or numeric: trading-day dummies (6 trading-day, 1 weekday, none, or automatic)}

\item{leap.year}{Character: automatic, forced, or no leap-year effect}

\item{easter}{Character: automatic, forced, or no Easter effect}

\item{forced.outliers}{A character vector of ourlier dates and types in X13 format (e.g. `c("ao2010.1", "tc2020.3")`)}

\item{m7.threshold}{Numeric between 0 and 3: the procedure will produce SA series if the M7 statistic is less than this threshold. A value of 3 means that adjustment is always done.}

\item{sa.rule}{Character: what kind of indicator compare to `m7.threshold`.}

\item{transform.aicdiff}{Numeric: the AICc difference between the additive (linear) and multiplicative (log) model; use log if AICc(nolog) - AICc(log) < aicdiff; by default, prefers multiplicative models}

\item{tradingdays.aicdiff}{Numeric: the AICc difference for the TD or WD dummies to be added into the model (if negative, prefers more parsimonious models)}

\item{plot.file}{A string containing the path to the output PNG file. If NULL, plot to the current device. Using NA prevents any plot from being created.}

\item{skip.boxplot}{Logical: remove boxplots in the background of the seasonal plot?}

\item{verbose}{Logical or integer. TRUE or 1 = basic output, 2  = detailed output.}

\item{bfcast.tails}{Logical: if x starts or ends with NA, produce the backcasts and forecasts for those periods?}

\item{est.begin}{An integer vector of length 2 denoting the beginning of the estimation sample. By default, the first valid observation.}

\item{est.end}{An integer vector of length 2 denoting the end of the estimation sample. By default, no forecasts are produced.}

\item{bcast.begin}{An integer vector of length 2 denoting the first period till which backcasts should be computed. By default, no backcasts are produced.}

\item{fcast.end}{An integer vector of length 2 denoting the last period till which backcasts should be computed. By default, no forecasts are produced.}

\item{split.long}{If TRUE, long time series will be adjusted in chunks and then, blended together.
Ignored if `custom.starts` is not `NULL`}

\item{max.length}{Numeric: length of a chunk in years. Ignored if `split.long` is `FALSE` or if
`custom.[est.starts, est.ends]` is not `NULL`.}

\item{overlap.length}{Numeric: the end of one chunk will be blended with the beginning of another chunk over this number of years}

\item{custom.est.starts}{A list of length-2 vectors, a data frame or a matrix with two columns:
year and period denoting the starts of each chunk}

\item{custom.est.ends}{A list of length-2 vectors, a data frame or a matrix with two columns:
year and period denoting the ends of each chunk}

\item{custom.blend.starts}{A list of length-2 vectors, a data frame or a matrix with two columns:
year and period denoting the starts of blending periods between 2 estimation windows}

\item{custom.blend.ends}{A list of length-2 vectors, a data frame or a matrix with two columns:
year and period denoting the ends of blending periods between 2 estimation windows}

\item{parallel}{If TRUE, estimates multiple series in parallel}

\item{mc.cores}{The number of cores for the cluster to speed up the computations.

If prediction out of the sample is requested and the calendar is custom, then,
the calendar should be as long as the forecast horizon.

Since seasonal adjustment via X13 implies estimation with TRAMO-like methods that allow missingness,
the returned series "predicted" will contain fitted values in places where the original data had middle gaps.

`diagnoseSeasonalityOne` does one adjustment, `diagnoseSeasonality` does the same
one adjustment if the series are univariate and short, and multiple adjustments
otherwise: for east series, if it is shorter than `max.length`, apply `diagnoseSeasonalityOne`,
or split it into chunks, adjust the chunk, and cleverly glue them back without
losing the accessible quality statistics for the last sample and adding the extra
measurements of how different the revised adjusted values are.}
}
\value{
A list:
* `seasonality`: a logical indicating whether there is either seasonal or calendar effects
* `multiplicative`: a logical indicating whether the adjustment model is multiplicative
* `quality`: a list containing brief diagnostic information
* `series`, an mts containing the decomposition
* `seas`: the full output of the X13 `seas()` run for the best model)
* `date`: the dates of the input series
* `si.robtests`: robust seasonality test results (IRLS with HAC for seasonal and/or yearly dummies)
}
\description{
Diagnose seasonality, adjust the series, print and visualise the results
}
\examples{
# Simulating ARIMA with trend, decaying seasonality, 1 LS and 1 AO
addTS <- function(x) ts(x, end = c(2022, 12), freq = 12)
x <- seq(0, 7.99, 1/12)
set.seed(1)
ybase <- addTS(arima.sim(n = 96, list(ar = 0.8, ma = 0.3))) # ARIMA(1, 0, 1)
yseas <- addTS(40/(x+20)*cos(x*pi*2))
oreg <- addTS(5*(x >= 6) - 4*(x == 5))
y1 <- 10 + 0.05*x + oreg + yseas + ybase
ysa <- diagnoseSeasonality(y1)
summary(ysa$seas)
ysa.mult <- diagnoseSeasonality(y1, transform = "yes")
# ysa.add <- diagnoseSeasonality(y1, transform = "no")
ysa.td6 <- diagnoseSeasonality(y1, td = 6)
# ysa.td1 <- diagnoseSeasonality(y1, td = 1)
# ysa.td0 <- diagnoseSeasonality(y1, td = 0)
ysa.ly <- diagnoseSeasonality(y1, leap.year = "yes")
# ysa.ly0 <- diagnoseSeasonality(y1, leap.year = "no")
ysa.ea <- diagnoseSeasonality(y1, easter = "yes")
ysa.le <- diagnoseSeasonality(y1, easter = "yes", leap.year = "yes")
# A completely manual model = several times faster
ysa.man <- diagnoseSeasonality(y1, td = 1, transform = "no", easter = "yes", leap.year = "no")
# Trim the sample, forecast tails
yfc <- diagnoseSeasonality(y1, transform = "no", td = "no",
         est.begin = c(2016, 7), est.end = c(2022, 9), bfcast.tails = TRUE)
plot(yfc$series[ , c("original", "predicted")], plot.type = "single", lty = 1:2)
# Similarly, if there are missing values at the tails, they can be easily forecast
# Simply add `bfcast.tails = TRUE`
y1m <- y1; y1m[89:96] <- NA; y1m[1:12] <- NA
yfc2 <- diagnoseSeasonality(y1m, bfcast.tails = TRUE, transform = "no", td = "no")
plot(yfc2$series[ , c("original", "predicted")], plot.type = "single", lty = 1:2)
# Forcing outliers
diagnoseSeasonality(y1, forced.outliers = "ao2016.1", transform = "no", td = "no")
# Missing values in the middle
y1g <- y1; y1g[39:40] <- NA
ymisssa <- diagnoseSeasonality(y1g, transform = "no", td = "no")
window(ts.union(ymisssa$series[, c("original", "predicted")]), start = c(2013, 1), end = c(2013, 6))

# Only seasonality
y2 <- ts(10 + 1.5*cos(x*pi*2) + ybase, start = c(2010, 1), freq = 12)
y2sa <- diagnoseSeasonality(y2)

# Only calendar effects---suppose that Fridays bring more sales
dates <- seq.Date(as.Date("2015-01-01"), as.Date("2022-12-31"), by = "day")
wdays   <- as.numeric(strftime(dates, "\%u"))
yearmonth <- format(dates, "\%Y-\%m")
nfridays <- aggregate(wdays == 5, by = list(yearmonth), FUN = sum)$x
y3 <- addTS(10 + 0.2*x + ybase + nfridays)
plot(y3) # No obvious seasonality
y3sa <- diagnoseSeasonality(y3)
getCalendars("Luxembourg")
y3lu <- diagnoseSeasonality(y3, calendar = cal.lu.m)

# Only weekend effects
set.seed(1)
nwe <- aggregate(wdays \%in\% 6:7, by = list(yearmonth), FUN = sum)$x / 5
y4 <- addTS(rnorm(96) + nwe)
y4sa <- diagnoseSeasonality(y4)
plot(ts.union(y4sa$series[, "adjfac"], nwe - mean(nwe)),
     plot.type = "single", col = 2:1)

# Quarterly data
apsa <- diagnoseSeasonality(datasets::AirPassengers)
summary(apsa$seas)

# Long series without any seasonal effects
set.seed(1)
ywn <- addTS(rnorm(500))
ylong <- diagnoseSeasonality(ywn, verbose = 1)
plot(ylong$series, main = "Piecewise SA")
plotSeas(ylong$seas) # What X13 sees
plotSeas(ylong$seas, sa.custom = ylong$series[, "adjusted"]) # What is used
ylong2 <- diagnoseSeasonality(ywn, verbose = 1, return.only.last = FALSE)
plotSeas(ylong2[[1]]$seas, sa.custom = ylong2[[1]]$series[, "adjusted"])
plotSeas(ylong2[[3]]$seas)
# Stability diagnostics
ylong$stability.inds # Erratic because the original is white noise

# Long series with strong but devolving seasonality
x <- seq(0, 40, 1/12)
set.seed(1)
ybase <- addTS(arima.sim(n = 481, list(ar = 0.8, ma = 0.3))) # ARIMA(1, 0, 1)
yseas <- 60/(x+10)*cos(x*pi*2)
ylong3 <- addTS(10 + 0.07*x + yseas + ybase)
plot(ts.union(ylong3, ylong3 - ybase), col = 1:2, plot.type = "single")
# We try windows of length 10, 15, 20
y10 <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
                           max.length = 10)
y15 <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
                           max.length = 15)
y15n <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
                           max.length = 15, overlap.length = 0)
y25 <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
                           max.length = 25, overlap.length = 1/12) # Only 1-point overlap
getSAStat(list(y10, y15, y15n, y25))
plotSeas(y10)
plotSeas(y15)
plotSeas(y15n)
plotSeas(y25)
plotSeas(y25, span.index = 1)
round(cbind(`10+1y` = y10$stability.inds, `15+1y` = y15$stability.inds,
            `15+0` = y15n$stability.inds, `25+1m` = y25$stability.inds), 3)
# As expected, with no overlap, there are no diagnostics, and with 1-point overlap,
# the diagnostics are unreliable, and no SDs are available

# Long series with forecasting and backcasting
ylong.fc <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
              bfcast.tails = TRUE, bcast.begin = c(1981, 1),
              fcast.end = c(2000, 4), est.end = c(1999, 4), max.length = 10)
plotSeas(ylong.fc)
yshort.fc <- diagnoseSeasonality(ylong3, transform = "no", easter = "no", leap.year = "no",
              bfcast.tails = TRUE, est.end = c(1995, 4), bcast.begin = c(1981, 1),
              fcast.end = c(1995, 12))
plotSeas(yshort.fc)
# No problems when there is only one point
yshort.fc2 <- diagnoseSeasonality(ylong3, est.end = c(1999, 12), max.length = 10,
               bcast.begin = c(1982, 11), fcast.end = c(2000, 1), bfcast.tails = TRUE,
               transform = "no", easter = "no", leap.year = "no")
plotSeas(yshort.fc2)

set.seed(1)
x <- ts(rnorm(500), end = c(2022, 12), freq = 12)
a <- diagnoseSeasonality(x, max.length = 15)
# Custom breaks
ce.st <- matrix(c(1981, 5, 1990, 1, 2005, 8, 2015, 2), ncol = 2, byrow = TRUE)
ce.en <- matrix(c(1991, 1, 2007, 1, 2015, 1, 2022, 12), ncol = 2, byrow = TRUE)
a2 <- diagnoseSeasonality(x, td = 0, transform = "no", leap.year = "no", easter = "no",
                          custom.est.starts = ce.st, custom.est.ends = ce.en)
# One break = supply the breaks as a list
a3 <- diagnoseSeasonality(AirPassengers, transform = "yes", td = 1,
                          custom.est.starts = list(c(1949, 1),  c(1953, 1)),
                          custom.est.ends   = list(c(1957, 12), c(1960, 12)),
                          custom.blend.starts = list(c(1953, 7)),
                          custom.blend.ends   = list(c(1953, 12))
                          )
}

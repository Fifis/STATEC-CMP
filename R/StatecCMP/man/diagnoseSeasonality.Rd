% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sa.R
\name{diagnoseSeasonality}
\alias{diagnoseSeasonality}
\title{Diagnose seasonality, adjust the series, print and visualise the results}
\usage{
diagnoseSeasonality(
  x,
  calendar = NULL,
  name = "Y",
  bfcast.tails = FALSE,
  sample.begin = NULL,
  sample.end = NULL,
  force.multiplicative = FALSE,
  m7.threshold = 1,
  m7.rule = c("robust", "original", "average", "force"),
  transform.aicdiff = -2,
  tradingdays.aicdiff = 0,
  plot.file = NULL,
  seasonal.plot = TRUE,
  min.outliers = 1,
  verbose = 2
)
}
\arguments{
\item{x}{A numeric vector of univariate time series of class "ts".}

\item{calendar}{An object of class "ts" containing calendar regressors: Monday, ..., Saturday, LeapYear, WorkingDays. If NULL, the default X13 working-day calendar is used.}

\item{name}{A string with the name of the series for printing.}

\item{bfcast.tails}{Logical: if x starts or ends with NA, produce the backcasts and forecasts for those periods?}

\item{sample.begin}{An integer vector of length 2 denoting the beginning of backcast period. By default, no backcasts are used.}

\item{sample.end}{An integer vector of length 2 denoting the end of forecast period. By default, predicts the seasonality adjustment factor for 1 year out of sample.}

\item{force.multiplicative}{If TRUE, forces multiplicative adjustment.}

\item{m7.threshold}{Numeric between 0 and 3: the procedure will produce SA series if the M7 statistic is less than this threshold. A value of 3 means that adjustment is always done.}

\item{m7.rule}{Character: what kind of indicator compare to `m7.threshold`.}

\item{transform.aicdiff}{Numeric: the AICc difference between the additive (linear) and multiplicative (log) model; use log if AICc(nolog) - AICc(log) < aicdiff; by default, prefers multiplicative models}

\item{tradingdays.aicdiff}{Numeric: the AICc difference for the TD or WD dummies to be added into the model (if negative, prefers more parsimonious models)}

\item{plot.file}{A string containing the path to the output PNG file. If NULL, plot to the current device. Using NA prevents any plot from being created.}

\item{seasonal.plot}{Logical: replace box plot with series plot?}

\item{min.outliers}{An integer: the number of models in which a candidate outlier must appear to be included in the AIC test.
If 1, test the model for selection with a common list of all outliers (appearing at least once in the regressions with 6 TD, 1 TD, and no TD). If 2, test with outliers
existing in at least 2 out of 3 specifications. Cannot be greater than 3.}

\item{verbose}{Logical or integer. TRUE or 1 = basic output, 2  = detailed output.

Since seasonal adjustment via X13 implies estimation with TRAMO-like methods that allow missingness,
the returned series "predicted" will contain fitted values in places where the original data had middle gaps.}
}
\value{
A list:
* `seasonality`: a logical indicating whether there is either seasonal or calendar effects
* `multiplicative`: a logical indicating whether the adjustment model is multiplicative
* `quality`: a list containing brief diagnostic information
* `series`, an mts containing the decomposition
* `seas`: the full output of the X13 `seas()` run for the best model)
* `date`: the dates of the input series
* `si.robtests`: robust seasonality test results (IRLS with HAC for seasonal and/or yearly dummies)
}
\description{
Diagnose seasonality, adjust the series, print and visualise the results
}
\examples{
# Simulating ARIMA with trend, decaying seasonality, 1 LS and 1 AO
x <- seq(0, 7.99, 1/12)
set.seed(1)
ybase <- arima.sim(n = 96, list(ar = 0.8, ma = 0.3)) # ARIMA(1, 0, 1)
yseas <- 40/(x+20)*cos(x*pi*2)
oreg <- 5*(x >= 6) - 4*(x == 5)
y1 <- ts(10 + 0.05*x + oreg + yseas + ybase, start = c(2010, 1), freq = 12)
ysa <- diagnoseSeasonality(y)
summary(ysa$seas) # Some calendar effects were auto-detected
ysal <- diagnoseSeasonality(y, force.multiplicative = TRUE)

# Only seasonality
y2 <- ts(10 + 1.5*cos(x*pi*2) + ybase, start = c(2010, 1), freq = 12)
y2sa <- diagnoseSeasonality(y2)

# Only calendar effects---suppose that Fridays bring more sales
dates <- seq.Date(as.Date("2010-01-01"), as.Date("2017-12-31"), by = "day")
wdays   <- as.numeric(strftime(dates, "\%u"))
yearmonth <- format(dates, "\%Y-\%m")
nfridays <- aggregate(wdays == 5, by = list(yearmonth), FUN = sum)$x
y3 <- ts(10 + 0.2*x + ybase + nfridays, start = c(2010, 1), freq = 12)
plot(y3) # No obvious seasonality
y3sa <- diagnoseSeasonality(y3)

# Only weekend effects
set.seed(1)
nwe <- aggregate(wdays \%in\% 6:7, by = list(yearmonth), FUN = sum)$x / 5
y4 <- ts(rnorm(96) + nwe, start = c(2010, 1), freq = 12)
y4sa <- diagnoseSeasonality(y4)
plot(ts.union(y4sa$series[, "adjfac"], nwe - mean(nwe)),
     plot.type = "single", col = 2:1)

# Quarterly data
apsa <- diagnoseSeasonality(datasets::AirPassengers)
summary(apsa$seas)
}
